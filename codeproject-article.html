<!-- HTML for article "Visual Leak Detector - Enhanced Memory Leak Detection for Visual C++" by Dan Moulding,Dan Moulding
     URL: http://www.codeproject.com/tools/visualleakdetector.asp

     Article content copyright Dan Moulding,Dan Moulding
     All formatting, additions and alterations Copyright © CodeProject, 1999-2005
-->
<!----------------------------- Ignore ----------------------------->
<link rel="stylesheet" type=text/css href="http://www.codeproject.com/styles/global.css">
<p><b>Please choose 'View Source' in your browser to view the HTML, or  
File | Save to save this file to your hard drive for editing.</b></p>
<hr size=1 noshade>
<!----------------------------- Ignore ----------------------------->


<!----------------------------- Article Starts ----------------------------->

<ul class="download">
    <li><a href="http://www.codeproject.com/tools/visualleakdetector/vld-10.zip">Download Visual Leak Detector - 477 Kb</a></li>

    <li><a href="http://www.codeproject.com/tools/visualleakdetector/vld-10-vc6-console-project.zip">Download a demo console project - 480 Kb</a></li>

    <li><a href="http://www.codeproject.com/tools/visualleakdetector/vld-10-vc6-mfc-project.zip">Download a demo MFC project - 487 Kb</a></li>

    <li><a href="http://www.codeproject.com/tools/visualleakdetector/vld-10-src.zip">Download the source code - 51 Kb</a></li>
</ul>


<p>
    <img src="http://www.codeproject.com/tools/visualleakdetector/screenshot.png" alt="Screenshot of Visual Studio 6.0 with Visual Leak Detector's memory leak report displayed." width="600" height="436">
</p>


<div style="float: right; margin: 1em; background-color: #f0f0f0;">
<h2 style="text-align: center;">Table of Contents</h2>

<ul style="margin: 0; padding: 0; list-style: none;">
    <li style="margin: 1em;"><a href="#new">What's New?</a></li>

    <li style="margin: 1em;"><a href="#intro">Introduction</a></li>

    <li style="margin: 1em;"><a href="#use">Using Visual Leak Detector</a></li>

    <li style="margin: 1em;"><a href="#make">Making a Memory Leak Detector</a></li>

    <li style="margin: 1em;"><a href="#source">Key Parts of the Source Code</a></li>

    <li style="margin: 1em;"><a href="#bandr">Known Bugs and Restrictions</a></li>

    <li style="margin: 1em;"><a href="#credits">Credits</a></li>

    <li style="margin: 1em;"><a href="#references">References</a></li>

    <li style="margin: 1em;"><a href="#license">License</a></li>

    <li style="margin: 1em;"><a href="#history">History</a></li>
</ul>
</div>


<h2 id="new">What's New?</h2>

<p><strong>5 August 2005:</strong> Visual Leak Detector 1.0 has finally arrived. If you are currently using an older version, this
   release should definitely be worth an upgrade. A couple of new features have been added, and a few bugs have been fixed:</p>

<ul>
    <li>Memory leak detection can now be selectively disabled and enabled at runtime, using provided APIs. This provides a
        straight-forward way of allowing VLD to selectively "ignore" certain allocations. It can also be used to disable VLD
        altogether at runtime, improving application performance without needing to recompile.</li>

    <li>If there are multiple identical memory leaks (i.e. leaks that originate from the same call stack and that leak the same size
        memory block) then VLD can optionally aggregate all of the repeated leaks, showing only the first such leaked block in
        detail in the memory leak report. A tally of the total number of leaks that match that particular size and call stack
        accompanies the information for that leak.</li>

    <li>Several other minor enhancements, too many to list here, have also been made.</li>
</ul>

<p>Bugs fixed since the last release include:</p>

<ul>
    <li>If the MFC libraries are statically linked to the program being debugged, then MFC will erroneously report memory leaks in
        the Visual Leak Detector code and may cause an access violation while attempting to report the false memory leaks. These
        bogus leaks are always reported as "client block at &lt;address&gt;, subtype bf42" and are claimed to be "invalid
        objects".</li>

    <li>VLD will leak a fixed-sized block of memory when the program exits if VLD failed to initialize because the Debug Help
        library (<span style="font-style: italic;">dbghelp.dll</span>) could not be loaded.</li>

    <li>In multithreaded programs, if the program's main thread terminates before other threads in the same process, then VLD may
        cause an access violation while freeing resources used internally by VLD.</li>
</ul>


<h2 id="intro">Introduction</h2>

<p>Visual&nbsp;C++ provides built-in memory leak detection, but its capabilities are minimal at best. This memory leak detector was
   created as a free alternative to the built-in memory leak detector provided with Visual&nbsp;C++. Here are some of
   Visual&nbsp;Leak&nbsp;Detector's features, none of which exist in the built-in detector:</p>

<ul>
    <li>Provides a complete stack trace for each leaked block, including source file and line number information when
        available.</li>

    <li>Provides complete data dumps (in hex and ASCII) of leaked blocks.</li>

    <li>Customizable level of detail in the memory leak report.</li>
</ul>

<p>Other after-market leak detectors for Visual&nbsp;C++ are already available. But most of the really popular ones, like Purify and
   BoundsChecker, are very expensive. A few free alternatives exist, but they're often too intrusive, restrictive, or unreliable.
   Here's some key advantages that Visual&nbsp;Leak&nbsp;Detector has over many other free alternatives:</p>

<ul>
    <li>Visual&nbsp;Leak&nbsp;Detector is cleanly packaged as an easy-to-use library. You don't need to compile its source code to
        use it. And you only need to make minor additions to your own source code to integrate it with your program.</li>

    <li>In addition to providing stack traces with source files, line numbers, and function names, Visual&nbsp;Leak&nbsp;Detector
        also provides data dumps.</li>

    <li>It works with both C++ and C programs (compatible with both <code>new</code>/<code>delete</code> and
        <code>malloc</code>/<code>free</code>).</li>

    <li>The full source code to the library is included and it is well documented, so it is easy to customize it to suit your
        needs.</li>
</ul>

<p>Visual Leak Detector is <a href="#license">licensed</a> free of charge as a service to the Windows developer community.</p>


<h2 id="use">Using Visual Leak Detector</h2>

<p>This section briefly describes the basics of using Visual&nbsp;Leak&nbsp;Detector (VLD). For a more in-depth discussion of the
   configuration options, runtime APIs, and a discussion of more advanced usage scenarios (such as using VLD with DLLs), please see
   the full documentation included in the downloadable zip files.</p>

<p>To use VLD with your project, follow these simple steps:</p>

<ol>
    <li>Copy the VLD library (<span style="font-style: italic;">*.lib</span>) files to your Visual&nbsp;C++ installation's "lib"
        subdirectory.</li>

    <li>Copy the VLD header files (<span style="font-style: italic;">vld.h</span> and
        <span style="font-style: italic;">vldapi.h</span>) to your Visual&nbsp;C++ installation's "include" subdirectory.</li>

    <li>In the source file containing your program's main entry point, include the <span style="font-style: italic;">vld.h</span>
        header file. It's best, but not absolutely required, to include this header before any other header files, except for
        <span style="font-style: italic;">stdafx.h</span>. If the source file includes
        <span style="font-style: italic;">stdafx.h</span>, then <span style="font-style: italic;">vld.h</span> should be included
        after it.</li>

    <li>If you are running Windows 2000 or earlier, then you will need to copy <span style="font-style: italic;">dbghelp.dll</span>
        to the directory where the executable being debugged resides.</li>

    <li>Build the debug version of your project.</li>
</ol>

<p>VLD will detect memory leaks in your program whenever you run the debug version under the Visual&nbsp;C++ debugger. A report of
   all the memory leaks detected will be displayed in the debugger's output window when your program exits. Double-clicking on a
   source file's line number in the memory leak report will take you to that file and line in the editor window, allowing easy
   navigation of the code path leading up to the allocation that resulted in a memory leak.</p>

<p style="margin-left: 2em;"><strong>Note:</strong> When you build release versions of your program, VLD will not be linked into the
   executable. So it is safe to leave <span style="font-style: italic;">vld.h</span> included in your source files when doing
   release builds. Doing so will not result in any performance degradation or any other undesirable overhead.</p>


<h2 id="make">Making a Memory Leak Detector</h2>

<p>The goal of Visual&nbsp;Leak&nbsp;Detector was to build a better replacement for the memory leak detector built-in to Visual C++.
   With that in mind, I set out to use the same method used by the built-in detector, namely the CRT Debug Heap. But this new
   detector would provide enhancements -- primarily full stack traces, which can be <em>extremely</em> helpful for finding and
   fixing leaks.</p>

<h3>The Built-In Detector</h3>

<p>The built-in detector is pretty simple really. When a program is exiting, the CRT runs a bunch of cleanup code after
   <code>main</code> returns. If the built-in detector is enabled, then it runs a memory leak check as part of the cleanup
   procedure. The memory leak check simply looks at the debug heap: if there are any user blocks still allocated on the debug heap,
   then they must be memory leaks. The debug version of <code>malloc</code> stores the file and line number that allocated each
   block in the block's header at the time it is allocated. When the built-in detector identifies a memory leak, it simply peers inside
   the block header to get the file and line number. It then reports that information to the debugger where it is displayed.</p>

<p>Note that the built-in detector detects leaks without doing any monitoring of allocations or frees. It simply takes a snapshot of
   the heap just before the process terminates and determines if there are any leaks based on that snapshot. A snapshot of the heap
   only tells us if there <em>are</em> leaks; it does not tell us <em>how</em> they were leaked. Clearly, to determine the "how" we
   also need to obtain a stack trace. But to obtain a stack trace, we need to be able to monitor every allocation on-the-fly at
   runtime. This is what will distinguish our leak detector from the built-in one.</p>

<h3>Allocation Hooking</h3>

<p>Luckily for us, Microsoft has provided an easy way to monitor every allocation made from the debug heap: allocation hooks. An
   allocation hook is simply a user-supplied callback function that will be called just before each allocation is made from the
   debug heap. Microsoft has provided a function, <code>_CrtSetAllocHook</code>, which registers the allocation hook function with
   the debug heap. When the debug heap calls the allocation hook, one of the arguments passed is an ID number that uniquely
   identifies each allocation -- it's basically a serial number for each memory block allocated. There's not enough room in the
   memory block header for us to record any information directly in it, but we can use this unique ID number as a key to map each
   block to any data that we want to record.</p>

<h3>Walking the Stack</h3>

<p>Now that we have a way to be notified every time a block is allocated, as well as a way to uniquely identify each allocation, all
   that's left to do is to record the call stack each time an allocation occurs.  We could conceivably attempt to unwind the stack
   ourselves using inline assembly. But stack frames can be organized in different ways, depending on compiler optimizations and
   calling conventions, so it could become complicated to do it that way. Once again, Microsoft has provided us with a tool to help
   us out. This time it is a function that we can call iteratively to walk the stack, frame by frame. That function is
   <code>StackWalk64</code>.  It is part of the Debug Help Library (<span style="font-style: italic;">dbghelp.dll</span>).As long
   as we provide it with the information that it needs to establish a starting "frame of reference", so to speak, it can examine our
   stack from there and reliably unwind it for us. Each time <code>StackWalk64</code> is called, it gives back a
   <code>STACKFRAME64</code> structure that can be reused as input for the next call to <code>StackWalk64</code>. It can be
   repeatedly called this way until the end of the stack is reached.</p>

<h3>Initializing the Memory Leak Detector</h3>

<p>We now have the beginnings of a better memory leak detector. We can monitor every allocation, and for each allocation monitored,
   we can obtain and record a stack trace. The only challenge that remains is to ensure that the allocation hook function is
   registered with the debug heap as soon as the program starts executing. This can be very simply solved by creating a global
   instance of a C++ class object. The constructor will run when the program is initialized. From the constructor, we can call
   <code>_CrtSetAllocHook</code> to register our allocation hook function. But wait, what if the program we are debugging already
   has <em>other</em> global C++ class objects that allocate memory? How can we ensure that our constructor will be called first,
   and that our allocation hook function will be installed before any other global objects are constructed? Unfortunately, the C++
   specification does not spell out any rules for deciding in which order to construct global objects. So there are no absolute
   guarantees that our constructor will be called first. But we can come very close to guaranteeing it. We can leverage a
   compiler-specific preprocessor directive that explicitly tells the compiler to ensure that our global variable is constructed as
   soon as possible: <code>#pragma init_seg (compiler)</code>. This directive tells the compiler to place our global object in the
   "compiler" initialization segment. Objects in this segment are the first to be constructed. Next, objects in the "library"
   segment are constructed, and objects in the "user" segment are constructed last. The "user" segment is the default segment for
   global objects. Generally speaking, no normal user objects should ever be placed in the "compiler" segment, so this provides a
   reasonable amount of certainty that our global object will be constructed before any user objects.</p>

<h3>Detecting Memory Leaks</h3>

<p>Because global objects are destroyed in the inverse order they are constructed, our global object will be destroyed after any
   user objects. We can then examine the heap, just like the built-in detector does. If we find a block on the heap that has not
   been freed, it is a leak and we can look up its call stack using the unique ID number recorded by our allocation hook function.
   An STL map would work fine here for mapping the ID number to the call stacks. I didn't use an STL map because I wanted my library
   to be compatible with both new and old versions of Visual C++. The STL from older versions is incompatible with the newer
   versions, so I couldn't use any STL components. But the good new is that this gave me the opportunity to create a data structure
   similar in concept to the STL map, but with specific optimizations for use with my memory leak detector.</p>

<p>Do you remember that the built-in leak detector peers inside the memory block to get the name of the file and the line number
   where the block was allocated? Well, all we have for our call stack is a bunch of program addresses. Dumping all those hex
   numbers to the debugger wouldn't be of much use. To make those addresses more meaningful, we need to translate them to human
   readable information: files and line numbers (and function names too). Once again, Microsoft comes through with the tools that
   will help us do our job: the symbol handler APIs. Like <code>StackWalk64</code>, they also happen to be part of the Debug Help
   Library. I won't dwell on them in detail here, because there are a lot of them and they're pretty simple to use. They don't
   require as much ingenuity to use as <code>StackWalk64</code> does. We can use two of the symbol handler APIs to get the
   filenames, line numbers, and function names that we want. The aptly named <code>SymGetLineFromAddr64</code> translates addresses
   into source filenames and line numbers. Its sister API, <code>SymFromAddr</code> translates addresses into symbol names. For
   program addresses, which are what we have, the corresponding symbol name will be the name of the function containing that
   program address.</p>


<h2 id="source">Key Parts of the Source Code</h2>

<p>In case you got bored with the above section and skipped ahead, I'll summarize it here. In a nutshell, this memory leak detector
   works like this:</p>

<ol>
    <li>A global object is automatically constructed. It is the first object constructed. The constructor registers our allocation
        hook function.</li>

    <li>Every allocation eventually calls our allocation hook function. The allocation hook function obtains and records the call
        stack for each allocation. The call stack information is recorded in a specialized STL-like map.</li>

    <li>When the program terminates, the global object is the last object destroyed. It examines the heap and identifies leaks.
        Leaked blocks are looked up in the map and matched with their corresponding call stack. The resulting data is sent to the
        debugger to be displayed.</li>
</ol>

<h3>Step 1: Registering the Allocation Hook</h3>

<p>Here is the <code>VisualLeakDetector</code> class constructor. Note the call to <code>_CrtSetAllocHook</code>. This is where
   our callback function, <code>allochook</code>, is registered with the debug heap. The call to
   <code>linkdebughelplibrary</code> performs an explicit dynamic link with the Debug Help Library
   (<span style="font-style: italic;">dbghelp.dll</span>). Because VLD is itself a library, implicitly linking with the Debug Help
   Library through the import library <span style="font-style: italic;">dbghelp.lib</span> is undesirable; it would make the VLD
   library dependent on <span style="font-style: italic;">dbghelp.lib</span> at link-time.
   <span style="font-style: italic;">dbghelp.lib</span> will not be present on many Windows computers and it's not redistributable,
   so we need to link with the DLL at runtime in order to bypass the import library. There is a lot of other stuff going on in here
   as well, but most of it has to do with custom configuration options that VLD supports.</p>

<pre>
// Constructor - Dynamically links with the Debug Help Library and installs the
//   allocation hook function so that the C runtime's debug heap manager will
//   call the hook function for every heap request.
//
VisualLeakDetector::VisualLeakDetector ()
{
    // Initialize private data.
    m_mallocmap    = new BlockMap;
    m_process      = GetCurrentProcess();
    m_selftestfile = __FILE__;
    m_status       = 0x0;
    m_thread       = GetCurrentThread();
    m_tlsindex     = TlsAlloc();

    if (_VLD_configflags & VLD_CONFIG_SELF_TEST) {
        // Self-test mode has been enabled. Intentionally leak a small amount of
        // memory so that memory leak self-checking can be verified.
        strncpy(new char [21], "Memory Leak Self-Test", 21); m_selftestline = __LINE__;
    }

    if (m_tlsindex == TLS_OUT_OF_INDEXES) {
        report("ERROR: Visual Leak Detector: Couldn't allocate thread local storage.\n");
    }
    else if (linkdebughelplibrary()) {
        // Register our allocation hook function with the debug heap.
        m_poldhook = _CrtSetAllocHook(allochook);
        report("Visual Leak Detector Version "VLD_VERSION" installed ("VLD_LIBTYPE").\n");
        reportconfig();
        if (_VLD_configflags & VLD_CONFIG_START_DISABLED) {
            // Memory leak detection will initially be disabled.
            m_status |= VLD_STATUS_NEVER_ENABLED;
        }

        m_status |= VLD_STATUS_INSTALLED;
        return;
    }
    
    report("Visual Leak Detector is NOT installed!\n");
}
</pre>

<h3>Step 2: Walking the Stack</h3>

<p>Here is the function responsible for obtaining call stacks. This is perhaps the trickiest part of the entire program. Setting up
   for the first call to <code>StackWalk64</code> is where the tricky bit is. To start the stack trace, <code>StackWalk64</code>
   needs to know exactly where on the stack to begin walking. It never assumes that we want to start tracing from the current stack
   frame. This requires that we provide it with the address of the current frame, as well as the current program address. I've seen
   other examples that attempt to get this information by calling <code>GetThreadContext</code> to retrieve the current thread's
   context, which would contain both of the required addresses. But, as its documentation clearly states,
   <code>GetThreadContext</code> can't be relied upon to get valid information for a running thread. By definition, this means that
   <code>GetThreadContext</code> can't get a valid context for the current thread. A better approach is to get the required
   addresses directly, and the only way to do that is with inline assembly.</p>

<p>Obtaining the address of the current frame is easy: it's stored in a CPU register (EBP) that we can directly read it from. The
   program address is a little harder to obtain. Though there is a CPU register (EIP) that always contains the current program
   address, on Intel x86 CPUs it can't be read by software. But we can get the same address in a round-about way, by calling another
   function and from within that function obtaining the return address. The return address is the same as the program address that
   called the function. For this, I've created a separate function, <code>getprogramcounterx86x64</code>. Since we're already doing
   inline assembly, we could write a simple function call in assembly, instead of writing another C++ function, but to keep it
   easier to understand I've used C++ wherever it's possible to do so.</p>

<p>In the following code, <code>pStackWalk64</code, <code>pSymFunctionTableAccess64</code>, and <code>pSymGetModuleBase64</code> are
   all pointers to the functions exported by <span style="font-style: italic;">dbghelp.dll</span>.</p>

<pre>
// getstacktrace - Traces the stack, starting from this function, as far
//   back as possible.
//
//  - callstack (OUT): Pointer to an empty CallStack to be populated with
//    entries from the stack trace.
//
//  Return Value:
//
//    None.
//
void VisualLeakDetector::getstacktrace (CallStack *callstack)
{
    DWORD        architecture;
    CONTEXT      context;
    unsigned int count = 0;
    STACKFRAME64 frame;
    DWORD_PTR    framepointer;
    DWORD_PTR    programcounter;

    // Get the required values for initialization of the STACKFRAME64 structure
    // to be passed to StackWalk64(). Required fields are AddrPC and AddrFrame.
#if defined(_M_IX86) || defined(_M_X64)
    architecture = X86X64ARCHITECTURE;
    programcounter = getprogramcounterx86x64();
    __asm mov [framepointer], BPREG // Get the frame pointer (aka base pointer)
#else
// If you want to retarget Visual Leak Detector to another processor
// architecture then you'll need to provide architecture-specific code to
// retrieve the current frame pointer and program counter in order to initialize
// the STACKFRAME64 structure below.
#error "Visual Leak Detector is not supported on this architecture."
#endif // defined(_M_IX86) || defined(_M_X64)

    // Initialize the STACKFRAME64 structure.
    memset(&frame, 0x0, sizeof(frame));
    frame.AddrPC.Offset    = programcounter;
    frame.AddrPC.Mode      = AddrModeFlat;
    frame.AddrFrame.Offset = framepointer;
    frame.AddrFrame.Mode   = AddrModeFlat;

    // Walk the stack.
    while (count < _VLD_maxtraceframes) {
        count++;
        if (!pStackWalk64(architecture, m_process, m_thread, &frame, &context,
                          NULL, pSymFunctionTableAccess64, pSymGetModuleBase64, NULL)) {
            // Couldn't trace back through any more frames.
            break;
        }
        if (frame.AddrFrame.Offset == 0) {
            // End of stack.
            break;
        }

        // Push this frame's program counter onto the provided CallStack.
        callstack->push_back((DWORD_PTR)frame.AddrPC.Offset);
    }
}
</pre>

<p>And here is the function that retrieves the EIP register. Again, this has to be done as a separate function call because there is
   no way for software to directly read the EIP register. But the same value can be obtained by making a function call, and then
   from within the called function getting the return address. The return address is the program address that made the function
   call, and it is pushed onto the stack when the function call is made. We get it by copying it from the stack.</p>

<pre>
// getprogramcounterx86x64 - Helper function that retrieves the program counter
//   for getstacktrace() on Intel x86 or x64 architectures.
//
//  Note: Inlining of this function must be disabled. The whole purpose of this
//    function's existence depends upon it being a *called* function.
//
//  Return Value:
//
//    Returns the caller's program address.
//
#if defined(_M_IX86) || defined(_M_X64)
#pragma auto_inline(off)
DWORD_PTR VisualLeakDetector::getprogramcounterx86x64 ()
{
    DWORD_PTR programcounter;

    __asm mov AXREG, [BPREG + SIZEOFPTR] // Get the return address out of the current stack frame
    __asm mov [programcounter], AXREG    // Put the return address into the variable we'll return

    return programcounter;
}
#pragma auto_inline(on)
#endif // defined(_M_IX86) || defined(_M_X64)
</pre>

<h3>Step 3: Generating a Better Memory Leak Report</h3>

<p>Finally, here is the function that converts the program addresses obtained while walking the stack into useful symbol names. Note
   that the address-to-symbol conversion code is only run if memory leaks are detected. This avoids having to do symbol lookups
   on-the-fly while the program is running, which would add considerable additional overhead. Not to mention that it just doesn't
   make sense to store (large) symbol names for later retrieval when you can store (small) addresses instead.</p>

<p>The CRT doesn't expose any documented method for gaining access to it's internal linked-list of allocated memory blocks. This
   linked list is what is used by the built-in detector for taking a "snapshot" of the heap to determine if there are any memory
   leaks. I've come up with a very simple trick to gain access to the list. Any time a new memory block is allocated, it happens to
   be placed at the beginning of the linked-list. So, to get a pointer to the head of the list, I just allocate a temporary memory
   block. That block's address can be converted to the address of the containing <code>_CrtMemBlockHeader</code> structure and now
   I have a pointer to the beginning of the linked list.</p>

<p>In the following code, <code>pSymSetOptions</code>, <code>pSymInitialize</code>, <code>pSymGetLineFromAddr64</code>, and
   <code>pSymFromAddr</code> are all pointers to the functions exported by <span style="font-style: italic;">dbghelp.dll</span>.
   The <code>report</code> function is just a custom wrapper around <code>OutputDebugString</code> which sends messages to the
   debugger for display in the debugger's output window.</p>

<p>This function is quite long. To cut down on clutter, I've removed all of the uninteresting and trivial parts. To see this
   function in its entirety, please download the source ZIP file.</p>

<pre>
// reportleaks - Generates a memory leak report when the program terminates if
//   leaks were detected. The report is displayed in the debug output window.
//
//  Return Value:
//
//    None.
//
void VisualLeakDetector::reportleaks ()
{

    ...

    // Initialize the symbol handler. We use it for obtaining source file/line
    // number information and function names for the memory leak report.
    symbolpath = buildsymbolsearchpath();
    pSymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);
    if (!pSymInitialize(m_process, symbolpath, TRUE)) {
        report("WARNING: Visual Leak Detector: The symbol handler failed to initialize (error=%lu).\n"
               "    Stack traces will probably not be available for leaked blocks.\n", GetLastError());
    }

    ...

#ifdef _MT
    _mlock(_HEAP_LOCK);
#endif // _MT
    pheap = new char;
    pheader = pHdr(pheap)->pBlockHeaderNext;
    delete pheap;
    while (pheader) {

        ...

        callstack = m_mallocmap->find(pheader->lRequest);
        if (callstack) {

            ...

            // Iterate through each frame in the call stack.
            for (frame = 0; frame < callstack->size(); frame++) {
                // Try to get the source file and line number associated with
                // this program counter address.
                if (pSymGetLineFromAddr64(m_process, (*callstack)[frame], &displacement, &sourceinfo)) {

                    ...

                }

                // Try to get the name of the function containing this program
                // counter address.
                if (pSymFromAddr(m_process, (*callstack)[frame], &displacement64, pfunctioninfo)) {
                    functionname = pfunctioninfo->Name;
                }
                else {
                    functionname = "(Function name unavailable)";
                }

                ...

            }

            ...

        }
        pheader = pheader->pBlockHeaderNext;
    }
#ifdef _MT
    _munlock(_HEAP_LOCK);
#endif // _MT

    ...

}
</pre>


<h2 id="bandr">Known Bugs and Restrictions</h2>

<p>There are no currently no known bugs in the latest release, but there are some known restrictions:</p>

<ul>
    <li>VLD does not detect COM leaks, out-of-process resource leaks, or any other types of memory leaks that are not associated
        with the CRT heap. In simpler terms, VLD only detects memory leaks that are the result of calls to
        <code>new</code> or <code>malloc</code>. Keep in mind that VLD was created as an alternative to the built-in memory leak
        detector. It also only detects leaks from <code>new</code> and <code>malloc</code>.</li>

    <li>VLD is not compatible with version 6.5 of the Debug Help library (<span class="filename">dbghelp.dll</span>). The
        recommended version of <span class="filename">dbghelp.dll</span> to use with VLD is 6.3. Version 6.3 is included in the VLD
        distribution.</li>

    <li>The pre-compiled libraries included in the VLD distribution may not be compatible with Visual&nbsp;Studio&nbsp;2005. If you
        need to use VLD with Visual&nbsp;Studio&nbsp;2005, <a href="#build">building VLD from source</a> in
        Visual&nbsp;Studio&nbsp;2005 should create compatible libraries.</li>
</ul>

<h2 id="credits">Credits</h2>

<ul>
    <li>Thanks to Alexandre Nikolov for quickly discovering the bug in 0.9e and helping to slap together a quick fix.</li>

    <li>Credit for the idea of how to make VLD's global class <code>VisualLeakDetector</code> object get constructed before any
        other user global objects goes to cmk. Thanks cmk!</li>

    <li>Thanks to Nitrogenycs (aka Matthias) for discovering the <CODE>VLD_MAX_DATA_DUMP</CODE> infinite loop bug.</li>

    <li>Thanks to hsvcs (aka Holger) for discovering the <CODE>VLD_MAX_DATA_DUMP</CODE> compilation bug.</li>

    <li>Thanks to Don Clugston for pointing out to me that people sometimes do build optimized debug executables, and that I need to
        watch out for that.</li>
</ul>


<h2 id="references">References</h2>

<p>Here are some links to useful related articles and resources:</p>

<ul>
    <li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt__crtsetallochook.asp" target="_blank"><code>_CrtSetAllocHook</code></a>from the MSDN Library</li>

    <li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/stackwalk64.asp" target="_blank"><code>StackWalk64</code></a> from the MSDN Library</li>

    <li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/symbol_handling.asp" target="_blank">Using the Symbol Handler</a>, from the MSDN Library</li>
 
    <li><a href="ftp://download.intel.com/design/Pentium4/manuals/25366514.pdf" target="_blank">IA-32 Intel Architecture Software Developer's Manual Volume 1</a>. Section 3.5 explains the EIP register and how software can and cannot interact with it.</li>
</ul>


<h2 id="license">License</h2>

<p>Visual&nbsp;Leak&nbsp;Detector is distributed under the terms of the <a href="http://www.gnu.org/copyleft/lesser.html">GNU Lesser
   General Public License</a>. See the documentation included in the downloadable ZIP files for detailed licensing information.</p>


<h2 id="history">History</h2>

<p>This list gives a brief overview of the changes made from release to release. For a detailed description of changes made in each
   release, please see the change log, <span style="font-style: italic;">CHANGES.txt</span>, in the downloadable ZIP files.</p>

<ul style="list-style: none;">
    <li style="margin-bottom: 1em;"><strong>5 August 2005:</strong> Version 1.0 - A couple of new features have been added, and a
        few bugs have been fixed. Major revisions have been made to this article to bring it up to date with respect to the 1.0
        release.</li>

    <li style="margin-bottom: 1em;"><strong>2 May 2005:</strong> Version 0.9i - This release fixed several bugs. It also includes
        support for Windows x64.</li>

    <li style="margin-bottom: 1em;"><strong>22 April 2005:</strong> Version 0.9h -  This release contains a crucial fix for an
        internal logic bug in version 0.9g.</li>

    <li style="margin-bottom: 1em;"><strong>22 April 2005:</strong> Version 0.9g - This release contains a vastly improved internal
        search/sort algorithm that results in a significant overall performance boost.</li>

    <li style="margin-bottom: 1em;"><strong>13 April 2005:</strong>  Version 0.9f - This provides a quick fix for a bug in 0.9e that
        can cause crashes.</li>

    <li style="margin-bottom: 1em;"><strong>12 April 2005:</strong> - Version 0.9e - Solves compatibility problems between the
        pre-built libraries and Visual Studio .NET by removing use of STL components (the pre-built libraries are built in Visual
        Studio 6.0 and the STL is not compatible between .NET and 6.0).</li>

    <li style="margin-bottom: 1em;"><strong>30 March 2005:</strong> - Version 0.9d - First release of VLD as a set of pre-built
        libraries.</li>

    <li style="margin-bottom: 1em;"><strong>17 March 2005:</strong> - Version 0.9c - Fixed a compilation error if VLD_MAX_DATA_DUMP
        is defined.</li>

    <li style="margin-bottom: 1em;"><strong>15 March 2005:</strong> - Version 0.9b - Improved ability to detect leaks in global C++
        object constructors.</li>

    <li style="margin-bottom: 1em;"><strong>12 March 2005:</strong> - Version 0.9a - Initial public release.</li>
</ul>


<!----------------------------- Article Ends ----------------------------->